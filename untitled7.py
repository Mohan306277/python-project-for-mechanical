# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ugjfr--gL9_kR4n6QD9AW093-N3u6i7B
"""

import matplotlib.pyplot as plt

class PointLoad:
    def __init__(self, magnitude, position):
        self.magnitude = magnitude
        self.position = position

class Beam:
    def __init__(self, length):
        self.length = length
        self.loads = []

    def add_point_load(self, magnitude, position):
        self.loads.append(PointLoad(magnitude, position))

    def calculate_reactions(self):
        """Assume simply supported beam with supports at x=0 and x=L"""
        total_load = sum(load.magnitude for load in self.loads)
        moment_about_A = sum(load.magnitude * load.position for load in self.loads)
        Rb = moment_about_A / self.length
        Ra = total_load - Rb
        return Ra, Rb

    def shear_force_distribution(self, step=0.01):
        Ra, Rb = self.calculate_reactions()
        x_vals = []
        shear_vals = []
        shear = Ra
        current_load_index = 0

        for x in frange(0, self.length, step):

            while (current_load_index < len(self.loads) and
                   abs(x - self.loads[current_load_index].position) < step / 2):
                shear -= self.loads[current_load_index].magnitude
                current_load_index += 1

            x_vals.append(x)
            shear_vals.append(shear)

        return x_vals, shear_vals

def frange(start, stop, step):
    """Range function that supports float stepping"""
    while start <= stop:
        yield round(start, 5)
        start += step

def plot_shear_force(x, shear):
    plt.figure(figsize=(10, 4))
    plt.plot(x, shear, label='Shear Force', color='blue')
    plt.axhline(0, color='black', linewidth=0.8)
    plt.xlabel("Beam Length (m)")
    plt.ylabel("Shear Force (N)")
    plt.title("Shear Force Diagram")
    plt.grid(True)
    plt.legend()
    plt.show()
beam = Beam(length=10)
beam.add_point_load(500, 2)
beam.add_point_load(1000, 5)
beam.add_point_load(750, 7)

x_vals, shear_vals = beam.shear_force_distribution()
plot_shear_force(x_vals, shear_vals)

import matplotlib.pyplot as plt

class PointLoad:
    def __init__(self, magnitude, position):
        self.magnitude = magnitude  # Load in Newtons
        self.position = position    # Position from left support in meters

class Beam:
    def __init__(self, length):
        self.length = length
        self.loads = []

    def add_point_load(self, magnitude, position):
        self.loads.append(PointLoad(magnitude, position))

    def calculate_reactions(self):
        total_load = sum(load.magnitude for load in self.loads)
        moment_about_A = sum(load.magnitude * load.position for load in self.loads)
        Rb = moment_about_A / self.length
        Ra = total_load - Rb
        return Ra, Rb

    def bending_moment_distribution(self, step=0.01):
        Ra, Rb = self.calculate_reactions()
        x_vals = []
        moment_vals = []

        for x in frange(0, self.length, step):
            moment = 0
            moment += Ra * x  # Contribution from reaction at A

            for load in self.loads:
                if x >= load.position:
                    moment -= load.magnitude * (x - load.position)

            x_vals.append(x)
            moment_vals.append(moment)

        return x_vals, moment_vals

def frange(start, stop, step):
    while start <= stop:
        yield round(start, 5)
        start += step

def plot_bending_moment(x, moment):
    plt.figure(figsize=(10, 4))
    plt.plot(x, moment, label='Bending Moment', color='green')
    plt.axhline(0, color='black', linewidth=0.8)
    plt.xlabel("Beam Length (m)")
    plt.ylabel("Bending Moment (Nm)")
    plt.title("Bending Moment Diagram")
    plt.grid(True)
    plt.legend()
    plt.show()

# ---------------------------
# Example Usage
# ---------------------------

beam = Beam(length=10)  # Beam of 10 meters

# Add point loads: (magnitude in N, position in m)
beam.add_point_load(500, 2)
beam.add_point_load(1000, 5)
beam.add_point_load(750, 7)

x_vals, moment_vals = beam.bending_moment_distribution()
plot_bending_moment(x_vals, moment_vals)

import numpy as np
import matplotlib.pyplot as plt

class PointLoad:
    def __init__(self, magnitude, position):
        self.magnitude = magnitude  # Load in Newtons
        self.position = position    # Position in meters

class Beam:
    def __init__(self, length, E, I):
        self.length = length  # in meters
        self.E = E            # Young's modulus in Pascals
        self.I = I            # Second moment of area in m^4
        self.loads = []

    def add_point_load(self, magnitude, position):
        self.loads.append(PointLoad(magnitude, position))

    def calculate_reactions(self):
        total_load = sum(load.magnitude for load in self.loads)
        moment_about_A = sum(load.magnitude * load.position for load in self.loads)
        Rb = moment_about_A / self.length
        Ra = total_load - Rb
        return Ra, Rb

    def bending_moment_distribution(self, x_vals):
        Ra, Rb = self.calculate_reactions()
        Mx = []

        for x in x_vals:
            moment = Ra * x
            for load in self.loads:
                if x >= load.position:
                    moment -= load.magnitude * (x - load.position)
            Mx.append(moment)

        return np.array(Mx)

    def deflection_curve(self, num_points=500):
        x_vals = np.linspace(0, self.length, num_points)
        Mx = self.bending_moment_distribution(x_vals)

        # EI is constant
        EI = self.E * self.I

        # Numerical integration: theta = ∫M(x)/EI dx, y = ∫theta dx
        theta = np.zeros_like(x_vals)
        y = np.zeros_like(x_vals)

        dx = x_vals[1] - x_vals[0]

        for i in range(1, len(x_vals)):
            theta[i] = theta[i-1] + (Mx[i-1] + Mx[i]) * dx / (2 * EI)
            y[i] = y[i-1] + (theta[i-1] + theta[i]) * dx / 2

        # Adjust deflection to make it zero at the supports (simple supports)
        # Shift entire curve so deflection at right support is zero
        y_shift = np.interp(self.length, x_vals, y)
        y = y - y_shift

        return x_vals, y

def plot_deflection(x_vals, deflection_vals):
    plt.figure(figsize=(10, 4))
    plt.plot(x_vals, deflection_vals * 1000, label='Deflection (mm)', color='purple')
    plt.axhline(0, color='black', linewidth=0.8)
    plt.xlabel("Beam Length (m)")
    plt.ylabel("Deflection (mm)")
    plt.title("Deflection Curve of the Beam")
    plt.grid(True)
    plt.legend()
    plt.show()

# ---------------------------
# Example Usage
# ---------------------------

# Beam properties
L = 10              # length in meters
E = 200e9           # Young's Modulus in Pascals (e.g., steel)
I = 8.33e-6         # Moment of inertia in m^4

beam = Beam(L, E, I)

# Add point loads (N, position in m)
beam.add_point_load(1000, 4)
beam.add_point_load(1500, 6)

x_vals, y_vals = beam.deflection_curve()
plot_deflection(x_vals, y_vals)

